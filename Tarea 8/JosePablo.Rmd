---
title: Análisis de Datos I <br> Tarea 7
author:
  - "Maria Carolina Navarro Monge C05513"
  - "Tábata Picado Carmona C05961"
  - "Jose Pablo Trejos Conejo C07862"
output:
  rmdformats::robobook:
        code_folding: show
  html_document:
    toc: TRUE
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Librerias
```{r, warning=FALSE, message=FALSE}
library(dplyr)
```


# Ejercicio 7
**Programe funciones en R que reciben un DataFrame con datos binarios y calculan la matriz de distancias usando las fórmulas de distancia de Jaccard y de Russel-Rao respectivamente. Verifique los resultados con al menos dos ejemplos.**

Primeramente se procede a crear dos funciones las cuales recibirán un `DataFrame` con datos binarios y devolveran la distancia de *Jaccard* y de *Russel-Rao* respectivamente.

Se inicia con la función para la distancia de *jaccard*.
```{r}
calculate_jaccard_distance <- function(df){
  # Se obtiene el número de filas que será el número de filas y columnas de la 
  # matriz de distancias.
  size <- nrow(df)
  
  # Se inicializa la matriz de distancias en ceros.
  jaccard <- matrix(0, size, size)
  
  # Se generan los nombres para las filas y columnas. Este apartado es meramente
  # estético.
  names <- list()
  for(i in 1:size){
    names <- append(names, paste("x", i, sep = ""))
  }
  
  rownames(jaccard) <- names
  colnames(jaccard) <- names
  
  # Se calculan las distancias de jaccard.
  for(i in 1:(size-1)){
    for(j in (i+1):size){
      sum <- df[i,] + df[j,]
      p_i_j <- rowSums(sum == 2)[[1]]
      q_i_j <- rowSums(sum == 1)[[1]]
      
      jaccard[i,j] = 1 - p_i_j/(p_i_j+q_i_j)
    }
  }
  
  # Se eliminan los valores por debajo de la diagonal.
  jaccard[row(jaccard) - col(jaccard) > 0] <- NA
  
  # Se retorna la matriz redondeada al 2do decimal.
  return(round(jaccard, 2))
}
```

Ahora se crea la función para la distancia de *Russel-Rao*.
```{r}
calculate_russel_rao_distance <- function(df){
  # Se obtiene el número de filas que será el número de filas y columnas de la 
  # matriz de distancias.
  size <- nrow(df)
  
  # Un dato importante es que el numero de columnas del dataframe, corresponde 
  # al número de variables y por lo tanto se tiene que p = número de columnas.
  p <- ncol(df)
  
  # Se inicializa la matriz de distancias en ceros.
  russel_rao <- matrix(0, size, size)
  
  # Se generan los nombres para las filas y columnas. Este apartado es meramente
  # estético.
  names <- list()
  for(i in 1:size){
    names <- append(names, paste("x", i, sep = ""))
  }
  
  rownames(russel_rao) <- names
  colnames(russel_rao) <- names
  
  # Se calculan las distancias de russel_rao.
  for(i in 1:(size-1)){
    for(j in (i+1):size){
      sum <- df[i,] + df[j,]
      p_i_j <- rowSums(sum == 2)[[1]]
      
      russel_rao[i,j] = 1 - p_i_j/p
    }
  }
  
  # Se eliminan los valores por debajo de la diagonal.
  russel_rao[row(russel_rao) - col(russel_rao) > 0] <- NA
  
  # Se retorna la matriz.
  return(round(russel_rao, 2))
}
```

Ahora se ejecutan 2 ejemplos, el primero corresponde al mismo ejemplo visto en la presentación y el segundo es inventado.
```{r}
ejm_1 <- matrix(c(1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,1,1), 6, 4, 
                byrow = T)

ejm_2 <- matrix(c(1,0,1,1,0,1,1,0,1,1,0,0,0,0,1,1,1,0), 3, 6, 
                byrow = T)

df_1 <- data.frame(ejm_1)
df_2 <- data.frame(ejm_2)
```

**Ejm 1:** Matriz de distancia de *Jaccard*:
```{r}
calculate_jaccard_distance(df_1)
```

**Ejm 1:** Matriz de distancia de *Russel-Rao*:
```{r}
calculate_russel_rao_distance(df_1)
```

**Ejm 2:** Matriz de distancia de *Jaccard*:
```{r}
calculate_jaccard_distance(df_2)
```

**Ejm 2:** Matriz de distancia de *Russel-Rao*:
```{r}
calculate_russel_rao_distance(df_2)
```

# Ejercicio 8
**Programe funciones en R para la función Lance & Williams para la agregación del promedio y de Ward (que es un caso particular de la formula general de Jambu). Construya un pequeño ejemplo de prueba, es decir, dada una matriz de distancias (agregaciones) encuentre el mínimo, luego en esta matriz, usando las funciones antes programadas, reconstruya la matriz para el siguiente paso del algoritmo (elimine dos filas y dos columnas para luego colocar en su lugar una fila y una columna nuevas, no en general, es hacer un caso particular).**

Inicialmente para este ejercicio se deben crear las funciones para las agregaciones que se utilizan en las formulas de *Lance & Williams*. Por lo tanto, a continuación se crea la función que calculará la *agregación ward* para dos matrices numéricas `set_a` y `set_b` que fungirán como los conjuntos que almacenarán los puntos.
```{r}
delta_ward <- function(set_a, set_b){
  # Se verifica que se reciba una matriz y de recibirse un vector, se transforma
  # en una matriz 1xn.
  set_a <- if(is.matrix(set_a)) set_a else as.matrix(t(set_a))
  set_b <- if(is.matrix(set_b)) set_b else as.matrix(t(set_b))
  
  # Se calcula la cardinalidad de los conjuntos que en este caso corresponde al
  # producto entre el número de filas y columnas, pues este producto es da
  # la cantidad de elementos dentro de la matriz (conjunto).
  card_a <- nrow(set_a)*ncol(set_a)
  card_b <- nrow(set_b)*ncol(set_b)
  
  # Se obtienen los centros de gravedad que al tratarse de matroces numericas, 
  # corresponde a la media de toda la matriz.
  centroid_a <- mean(set_a)
  centroid_b <- mean(set_b)
  
  # Se calcula la agregación.
  delta <- ((card_a*card_b)/(card_a+card_b))*(centroid_a - centroid_b)**2
  
  # Se retorna el resultado.
  return(delta)
}
```

Ahora se procede con la *agregación promedio*.
```{r}
delta_prom <- function(set_a, set_b){
  # Se verifica que se reciba una matriz y de recibirse un vector, se transforma
  # en una matriz 1xn.
  set_a <- if(is.matrix(set_a)) set_a else as.matrix(t(set_a))
  set_b <- if(is.matrix(set_b)) set_b else as.matrix(t(set_b))
  
  # Se calcula la cardinalidad de los conjuntos que en este caso corresponde al
  # producto entre el número de filas y columnas, pues este producto es da
  # la cantidad de elementos dentro de la matriz (conjunto).
  card_a <- nrow(set_a)*ncol(set_a)
  card_b <- nrow(set_b)*ncol(set_b)
  
  # Se crea una matriz con todos los puntos que representará la unión de los 
  # conjuntos A y B.
  set_a_b <- rbind(set_a, set_b)
  
  # Se obtienen las distancias entre puntos.
  dists_a_b <- dist(set_a_b)
  
  # Se calcula la sumatorios de las distancias.
  dist_a_b <- sum(dists_a_b)
  
  # Finalmente se calcula la agregación.
  delta <- (1/(card_a*card_b))*dist_a_b
  
  return(delta)
}
```

Ya que se cuenta con las funciones para las distancias base, se procede a crear las funciones recursivas *Lance & Williams* iniciando con la *agregación ward*.
```{r}
delta_ward_joint <- function(set_j, set_a, set_b){
  # Se verifica que se reciba una matriz y de recibirse un vector, se transforma
  # en una matriz 1xn.
  set_j <- if(is.matrix(set_j)) set_j else as.matrix(t(set_j))
  set_a <- if(is.matrix(set_a)) set_a else as.matrix(t(set_a))
  set_b <- if(is.matrix(set_b)) set_b else as.matrix(t(set_b))
  
  # Se obtienen las cardinalidades de los conjuntos.
  card_j <- nrow(set_j)*ncol(set_j)
  card_a <- nrow(set_a)*ncol(set_a)
  card_b <- nrow(set_b)*ncol(set_b)
  
  delta <- (((card_j + card_a)*delta_ward(set_j, set_a) + 
             (card_j + card_b)*delta_ward(set_j, set_b) -
              card_j*delta_ward(set_a, set_b))/(card_a + card_b))
  
  return(delta)
}

```

Ahora se procede con la *agragación prom* recursiva.
```{r}
delta_prom_joint <- function(set_j, set_a, set_b){
  # Se verifica que se reciba una matriz y de recibirse un vector, se transforma
  # en una matriz 1xn.
  set_j <- if(is.matrix(set_j)) set_j else as.matrix(t(set_j))
  set_a <- if(is.matrix(set_a)) set_a else as.matrix(t(set_a))
  set_b <- if(is.matrix(set_b)) set_b else as.matrix(t(set_b))
  
  # Se obtienen las cardinalidades de los conjuntos.
  card_j <- nrow(set_j)*ncol(set_j)
  card_a <- nrow(set_a)*ncol(set_a)
  card_b <- nrow(set_b)*ncol(set_b)
  
  # Se calcula el delta según la formula de Lance y Williams.
  delta <- ((card_a*delta_prom(set_j, set_a) + card_b*delta_prom(set_j, set_b))/
            (card_a + card_b))
  
  return(delta)
}
```

Con el fin de probar la clusterización, se procede a crear una función que, dada una matriz incial de datos, calcule las distancias (agregaciones).
```{r}
dist_delta <- function(model, matrix){
  # Se define que agregación utilizar.
  delta <- if(model == "prom") delta_prom else delta_ward
  
  # Se genera una matriz de ceros que contendreá las agregaciones.
  distances <- matrix(0, nrow(matrix), nrow(matrix))
  
  # Se crea una lista para los nombres.
  names <- list()
  
  for(i in 1:nrow(matrix)){
    names <- append(names, paste("x", i, sep = ""))
  }
  
  rownames(distances) <- names
  colnames(distances) <- names
  
  # Se calculan las agregaciones.
  for(i in 1:(nrow(matrix) - 1)){
    for(j in (i+1):nrow(matrix)){
      distances[i,j] <- delta(matrix[i,], matrix[j,])
    }
  }
  
  # Se eliminan los valores por debajo de la diagonal.
  distances[row(distances) - col(distances) > 0] <- NA
  
  return(distances)
}
```

Ahora re crea una función que busca los indices en donde se encuentra el valor mínimo en la matriz de distancias.
```{r}
find_minimum_indexes <- function(distances){
  minimum <- distances[1,2]
  indexes <- c(1,2)
  
  for(i in 1:(nrow(distances) - 1)){
    for(j in (i+1):nrow(distances)){
      if(minimum > distances[i,j]){
        # Se actualiza el valor mínimo
        minimum <- distances[i,j] 
        
        # Se actualizan los indices.
        indexes[1] <- i
        indexes[2] <- j
      }
    }
  }
  
  return(indexes)
}
```


finalmente se crea la función recursivo que realizará el clustering.
```{r}
clustering <- function(model, distances, individuals_list, h, n){
  # Se define el delta a utilizar.
  delta_union <- if(model == "prom") delta_prom_joint else delta_ward_joint
  
  # Primero se busca el mínimo en la matriz de distancias y se guardan sus 
  # respectivos indices. Cabe resaltar que al tratarse de una matriz de 
  # distancias la fila y la columna encontradas representan los dos individuos
  # con agregación mínimo.
  individuals <- find_minimum_indexes(distances)
  
  # Se guardan los nombres que, hasta el momento, poseen los individuos a unir.
  names <- colnames(distances)[individuals]
  
  # Se crea un nuevo nombre.
  name <- paste("{", names[1], "-", names[2], "}", sep = "")
  
  if(h == n-2){
    return(name)
  }
  
  # Se crea el nuevo vector con los nombres.
  new_names <- c(name, colnames(distances)[-individuals])
  
  # Se elimina la filas y columnas con dichos individuos y se agregan nuevas con
  # las distancias calculadas apartir de la unión de ambos individuos.
  distances <- as.matrix(distances[-individuals, -individuals])
  
  # Se crea una nueva lista donde se elimina a los elementos que se unen.
  new_individuals_list <- individuals_list[-individuals]
  
  # Se inicializa un vector de ceros para aumentar la dimensión m de la matriz y  
  # agregar el vector de distancias más adelante.
  zeros <- rep(0, nrow(distances))
  
  # Se agrega dicho vector a la matriz de distancias.
  distances <- cbind(zeros,distances)
  
  # Ahora se inicializa el vector con las nuevas distancias sobre el nuevo
  # la unión de los nuevos individuos.
  union_distances <- rep(0, ncol(distances))
  
  # Se calculan las nuevas distancias.
  for(i in 1:length(new_individuals_list)){
    union_distances[i+1] <- delta_union(new_individuals_list[[i]], 
                                        individuals_list[[individuals[1]]], 
                                        individuals_list[[individuals[2]]]) 
  }
  
  # Ahora se une el vector creado con la matriz de distancias.
  distances <- rbind(union_distances, distances)
  
  # Se cambian los nombres.
  colnames(distances) <- new_names
  rownames(distances) <- new_names
  
  # Se eliminan los valores por debajo de la diagonal.
  distances[row(distances) - col(distances) > 0] <- NA
  
  # Se imprime la nueva matriz de distancias o agregaciones.
  cat("Iteración: ", h+1, "\n")
  print(round(distances,2))
  cat("\n\n")
  
  # Se unen los elementos más cercanos en una matriz.
  union_xi_xj <- rbind(individuals_list[[individuals[1]]],
                       individuals_list[[individuals[2]]])
  
  # Se agrega la unión a la lista existente.
  new_individuals_list <- c(list(union_xi_xj), new_individuals_list)
  
  # Se actualiza el h.
  h <- h+1
  
  # Se corre la función de forma recursiva.
  return(clustering(model, distances, new_individuals_list, h, n))
}
```

Dado el código anterior, se procede a realizar dos pruebas, una por agregación. 

Se crea la matriz de observaciones y a su vez, la lista con cada una de ellas. Esta lista será de suma utilidad cuando se ejecute la función recursiva.

```{r}
x_1 <- c(2,2,5,3,9)
x_2 <- c(1,3,5,2,6)
x_3 <- c(5,2,8,3,4)
x_4 <- c(8,2,1,4,5)
x_5 <- c(7,2,1,1,4)

# Creación de la matriz de observaciones.
x_t <- rbind(x_1,x_2,x_3,x_4,x_5)
print(x_t)

# Creación de la lista con las observaciones.
individuals_list <- list(x_1,x_2,x_3,x_4,x_5)
print(individuals_list)
```

Ahora se procede a generar las matrices de distancias para las dos agregaciones.
```{r}
ward_distances <- dist_delta("ward", x_t)
print(ward_distances)

prom_distances <- dist_delta("prom", x_t)
print(prom_distances)
```
Finalmente se corre la función `clustering` para cada agregación.
```{r}
# Se obtiene el cluster bajo la agregación ward.
cluster_ward <- clustering("ward", ward_distances, individuals_list, 0, 
                      length(individuals_list))

cat("Cluster ward final: ", cluster_ward)

# Se obtiene el cluster bajo la agregación prom.
cluster_prom <- clustering("prom", prom_distances, individuals_list, 0, 
                      length(individuals_list))

# Se imprimen los clusters.
cat("Cluster prom final: ", cluster_prom)
```

# Ejercicio 9
**Repita el ejercicio anterior con la fórmula general recursiva de Jambu.**

Note que para la formula de *agregacion ward*, se tiene que:

\[a_{4} = a_{5} = a_{6}$ = $a_{7} = 0\]

Y para la *agregación prom*, sucede que:

\[a_{3} = a_{4} = a_{5} = a_{6}$ = $a_{7} = 0\]

Entonces se procede a crear la función para la formula general de *Jambu*.
```{r}
delta_jambu <- function(modelo, set_z, set_x, set_y){
  # Se verifica que se reciba una matriz y de recibirse un vector, se transforma
  # en una matriz 1xn.
  set_z <- if(is.matrix(set_x)) set_x else as.matrix(t(set_x))
  set_x <- if(is.matrix(set_y)) set_y else as.matrix(t(set_y))
  set_y <- if(is.matrix(set_z)) set_z else as.matrix(t(set_z))
  
  # Se define que agregación se utilizará.
  delta <- if(modelo == "prom") delta_prom else delta_ward
  
  # Ahora se calculan los pesos de cada conjunto.
  q_z <- nrow(set_z)*ncol(set_z)
  q_x <- nrow(set_x)*ncol(set_x)
  q_y <- nrow(set_y)*ncol(set_y)
  
  # Se obtienen las constantes de la formula.
  a_1 <- if(modelo == "prom") 1/(q_x + q_z) else (q_x + q_z)/(q_x + q_y + q_z)
  a_2 <- if(modelo == "prom") 1/(q_y + q_z) else (q_y + q_z)/(q_x + q_y + q_z)
  a_3 <- if(modelo == "prom") 0 else -(q_z/(q_x + q_y + q_z))
  
  joint <- (a_1*delta(set_x, set_z) + a_2*delta(set_y, set_z) + 
            a_3*delta(set_x, set_y))
  
  return(joint)
}
```

Ahora se crea la función recursiva para probar la función previamente creada.
```{r}
clustering_jambu <- function(model, distances, individuals_list, h, n){
  # Se define el delta a utilizar.
  delta_union <- delta_jambu
  
  # Primero se busca el mínimo en la matriz de distancias y se guardan sus 
  # respectivos indices. Cabe resaltar que al tratarse de una matriz de 
  # distancias la fila y la columna encontradas representan los dos individuos
  # con agregación mínimo.
  individuals <- find_minimum_indexes(distances)
  
  # Se guardan los nombres que, hasta el momento, poseen los individuos a unir.
  names <- colnames(distances)[individuals]
  
  # Se crea un nuevo nombre.
  name <- paste("{", names[1], "-", names[2], "}", sep = "")
  
  if(h == n-2){
    return(name)
  }
  
  # Se crea el nuevo vector con los nombres.
  new_names <- c(name, colnames(distances)[-individuals])
  
  # Se elimina la filas y columnas con dichos individuos y se agregan nuevas con
  # las distancias calculadas apartir de la unión de ambos individuos.
  distances <- as.matrix(distances[-individuals, -individuals])
  
  # Se crea una nueva lista donde se elimina a los elementos que se unen.
  new_individuals_list <- individuals_list[-individuals]
  
  # Se inicializa un vector de ceros para aumentar la dimensión m de la matriz y  
  # agregar el vector de distancias más adelante.
  zeros <- rep(0, nrow(distances))
  
  # Se agrega dicho vector a la matriz de distancias.
  distances <- cbind(zeros,distances)
  
  # Ahora se inicializa el vector con las nuevas distancias sobre el nuevo
  # la unión de los nuevos individuos.
  union_distances <- rep(0, ncol(distances))
  
  # Se calculan las nuevas distancias.
  for(i in 1:length(new_individuals_list)){
    union_distances[i+1] <- delta_union(model, new_individuals_list[[i]], 
                                        individuals_list[[individuals[1]]], 
                                        individuals_list[[individuals[2]]]) 
  }
  
  # Ahora se une el vector creado con la matriz de distancias.
  distances <- rbind(union_distances, distances)
  
  # Se cambian los nombres.
  colnames(distances) <- new_names
  rownames(distances) <- new_names
  
  # Se eliminan los valores por debajo de la diagonal.
  distances[row(distances) - col(distances) > 0] <- NA
  
  # Se imprime la nueva matriz de distancias o agregaciones.
  cat("Iteración: ", h+1, "\n")
  print(round(distances,2))
  cat("\n\n")
  
  # Se unen los elementos más cercanos en una matriz.
  union_xi_xj <- rbind(individuals_list[[individuals[1]]],
                       individuals_list[[individuals[2]]])
  
  # Se agrega la unión a la lista existente.
  new_individuals_list <- c(list(union_xi_xj), new_individuals_list)
  
  # Se actualiza el h.
  h <- h+1
  
  # Se corre la función de forma recursiva.
  return(clustering(model, distances, new_individuals_list, h, n))
}
```

Finalmente se corren los ejemplos previamente ejecutados.
```{r}
# Se obtiene el cluster bajo la agregación ward.
cluster_ward_jambu <- clustering_jambu("ward", ward_distances, individuals_list, 0, 
                                       length(individuals_list))

cat("Cluster ward final: ", cluster_ward_jambu, "\n\n")

# Se obtiene el cluster bajo la agregación prom.
cluster_prom_jambu <- clustering_jambu("prom", prom_distances, individuals_list, 0, 
                                       length(individuals_list))

# Se imprimen los clusters.
cat("Cluster prom final: ", cluster_prom_jambu)
```